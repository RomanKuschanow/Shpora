# C++ Второй курс

Первым делом, программирование строится на взаимодействии программы с оперативной памятью устройства.
Вся RAM делиться на ячейки по 1 байту каждая. Но для удобного использования все эти ячейки, когда до них доходит очередь, зачастую
группируются для хранения большего объема данных. Так например целое число, если не
вдаваться в подробности, зачастую храниться в блоке из четырех ячеек памяти, то есть занимает 4 байта памяти.
В результате 32-битное целое число, а в 4 байтах именно 32 бита, может достигать значений от -2^31 до (2^31)-1.
Степень 31, а не 32 потому что первый бит отвечает за знак числа, если 0 то +, если 1 то -.

### основные типы данных С++:

- `int` - целое число
- `float` - дробное число
- `double` - дробное число с большим диапазоном допустимых чисел
- `char` - символ, по типу `'f'`, `'a'`, `'1'` и тп.
- `bool` - логический тип данных

### Блок №1

Теперь перейдем непосредственно к тому, как это выглядит на практике. Открой код, который находиться в файле `main.cpp`.
Его там много, но сейчас нас интересует участок выделенный "//1" сверху и снизу.
Сейчас по порядку разберемся что эти каракули на эльфийском значат.

> Сразу стоит оговориться что в конце почти каждой строки, за некоторыми исключениями, следует писать `;`
> Для начала запустите этот файл в любом компиляторе С++ и следите за тем что выводится в консоль
(Некоторые среды разработки, например Visual Studio не позволяют запускать код, в котором есть неинициализированные
> переменные
> поэтому, в случае если код не запустился, замените строку `int a;` на `int a = 0;` Дальше будет понятно что это
> значит)

Строка `int a;` это непосредственно выделение тех четырех байт памяти под целое число. Мы взяли где-то в памяти 4 байта,
присвоили им имя `а` и теперь можем обращаться к этой памяти как к чему-то единому, называя это целочисленной
переменной.

Дальше идет строка вывода данных в консоль. После `<<` может стоять строка, переменная или результат математического
действия. На этом этапе на экран выведется какое-то невнятное число, что является просто мусором, который покоился в этих
байтах до того, как мы его потревожили.

Строка `a = 1;` задает нашей переменной значение равное `1`, фактически это значит, что в те 4 байта памяти запишется
нечто вот такое: `00000000 00000000 00000000 00000001`. Тут 31 ноль и 1 единица в конце, это двоичное представление числа,
что в нашем случае не сильно отличается от десятичного.
Это действие, присвоение переменной начального значения, называется **инициализацией**.

На следующей строке мы опять выводим значение переменной, на этот раз оно выглядит приятнее, не правда ли.

### Блок №2

Теперь посмотрим на второй блок. Он заметно короче, но делает то же самое. Переменная `b` создается и приобретает
начальное значение в одной строке.

> Также добавлю, что в одной области видимости переменные с одинаковыми именами не допускаются.
> На практике это значит, что нам нужно стараться придумывать разные имена для всех новых переменных

### Блок №3

В третьем блоке у нас, на первый взгляд, происходит какая-то ересь, но нет, это просто прибавление значений переменных, в
нашем случае это все равно, что написать `int c = 1 + 1;`

### Блок №4

А четвертый блок выглядит как ночной кошмар математика. Все три строки на самом деле делают одно и тоже: просто к значению
переменной `c` прибавляют `1`. Первый способ это прировнять `c` к этой же `c` только `+ 1`. Старая двойка, которая там была,
перезапишется новым значением, в данном случае тройкой. То же самое, что мы делали в первом блоке, но теперь не просто число,
а математическое выражение. Второй способ называется сложение с присваиванием. Это действие прибавляет к изменяемой переменной
то число, которое написано в правой части, и потом записывает, получившийся результат, в эту же переменную - тройка перезапишется
четверкой. Есть так же `-=`, `*=`, `/=`, думаю достаточно очевидно, что они сделают.
Ну и третий способ: два плюса под ряд возле переменной - четверка перезапишется пятеркой.

> `++`/`--` меняет значение ТОЛЬКО на единицу (`--` отнимает единицу).

Все три способа на программном уровне работают одинаково, и один не является более правильным, а другой менее, просто
где-то удобно так, а где-то по другому.

### Блок №5

В пятом блоке попробуем создать новую переменную `d` и задать ей значение равное половине от `c` (помним что `c` у нас равно 5).
Для этого поделим `c` на `2`. На выходе мы ожидаем получить `2.5`, поскольку `5 / 2 = 2.5` Но компилятор уже спешит нас обламать
и выводит в консоль ровно 2. Вернемся к битам и байтам. Наше число `5` (если обрезать левые 24 нолика) выглядит вот
так: `00000101`
а число `2` выглядит так: `00000010`

Вспомним о типах данных. Мы все время использовали целое число, соответственно, если мы попытаемся присвоить
целочисленной переменной дробное число, то компьютеру ничего не останется, кроме как записать в переменную целую часть
числа, а дробную просто отбросить.

### Блок №6

Применив несколько уже упомянутых действий над переменными `c` и `d` мы получим ответ `3`, который полностью
соответствует нашим представлениям о делении числа `6` на `2`

### Блок №7

Теперь давай в седьмом примере попробуем получить дробное число. Для этого воспользуемся типом `float` при создании
переменной `e`. Но вот при делении `6` на `2`, мы опять получили целое число.
На этот раз поделим `e` на 2 еще раз с помощью оператора деления с присваиванием. Ура, дробное число получено, можешь
отметить этот день в своем календаре)))

### Блок №8

В восьмом примере я покажу разные способы установки значений для дробных чисел. Все выглядит вполне логично, за
исключением последнего варианта. В нем мы просто не указывали дробную часть,
но указали что это число дробное, тут это не особо полезно, но в дальнейшем мы еще будем это использовать.

> Теперь поиграемся немного с выводом данных в консоль. Думаю от твоего внимания не ускользнуло `<< endl` в конце
> каждого
> вывода. Это просто означает окончание строки и переход на новую.
> То же самое будет если написать `<< "\n"`.

### Блок №9

В девятом примере я вывожу в консоль все переменные которые мы успели создать, но теперь немного красивее. Мы выводим
строку в которой пишем название переменной и знак равно,
дальше выводим значение этой самой переменной, а в конце добавляем перенос на новую строку.

```
cout << "что-то что нужно вывести, переменная или просто текст";
cout << "опять что-то выводим " << "но на этот раз двумя частями, и таких частей может быть сколько угодно, главное разделять их знаками <<";
```

> "" означают что текст который в них написан будет восприниматься как строка, и если ты вставишь куда-то две верхние
> строки, то ты увидишь что текст вывелся без изменений.
> Но есть ты забудешь поставить кавычки, то программа просто не запуститься.

### Блок №10

И так, мы уже знаем как создавать и работать с числовыми переменными. Но на этом много не напрограммируешь, необходимо
как-то получать и обрабатывать данные из вне.
В модуле `iostream`, который мы подключали в самом верху, есть функция `cin`, которая принимает данные и записывает их в
переменную.

Давай посмотрим на десятый блок. Мы создали переменную `f`, но не задали ей никакого значения, потому что на следующей
строке мы ожидаем что пользователь введет его сам.
Как видишь значение у переменной `f` ровно такое, какое было введено.

### Блок №11

Нам осталось разобраться с последней недостающей деталькой, логическим типом данных.
Давай разбираться. Я создал переменную `h` с новым типом данных, логическим. Он занимает всего 1 байт и может быть равен
либо `0`, либо `1`, `0` это `ложь`, `1` это `правда`.
Идем дальше, строка `h = 1 == 1;` Что здесь происходит? Мы сравниваем `1` и `1`, равна ли единица единице. Разумеется
что
ответ правда, по этому на выходе мы получим значение `true`.

> Вот сейчас очень важно, `=` это приравнивание, с помощью этого оператора мы задаем значение, а `==` это сравнивание,
> мы
> сравниваем два значения.

Есть так же:

- `!` - отрицание
- `!=`- не равно
- `<` - меньше
- `>` - больше
- `<=` - меньше или равно
- `>=` - больше или равно

И так, переходим на третью строку: `h = 1 == 2;` Разумеется что `1` не равна `2`, по этому результат сравнения будет
`false`, что мы и видим на выходе.
Четвертая строка демонстрирует возможность сравнивать переменную с каким то значением или другой переменной.
Поскольку на прошлой строке у нас получилась ложь, то сравнение `false` и `false` вернет, ожидаемо, правду.
Ну и последняя строка, на которой мы берем значение обратное значению переменно `h`. Простыми словами это выглядит как
`не правда`, что по другому является `ложью`, именно ее мы и наблюдаем в консоли.

### Блок №12

Что ж, мы теперь полностью готовы к познанию того, как обрабатывать данные. В двенадцатом блоке мы видим так называемое
условие `if(условие){ действие }`. Дословно это можно перевести так: "Если утверждение в круглых скобках правдиво, то
выполнить действие в фигурных скобках". В нашем случае утверждение в скобках всегда правдиво, поскольку мы туда передаем
заведомо правдивое значение.

### Блок №13

В разделе 13 мы видим вторую часть условия `else{ действие }`, которая дословно обозначает "Иначе, если условие не
выполнилось, то...". В данном случае, поскольку наша переменная `h` все еще равна `false`, то выполниться блок `else`

### Блок №14

Продолжаем познавать все прелести условий. На этот раз у нас добавился блок `else if(условие){ действие }`, который
будет выполнен в случае если первое условие не выполнилось. Дословно это значит "Иначе если первое условие не сработало,
то проверить другое условие". Стоит заметить что таких блоков с дополнительными условиями может быть сколько угодно,
главное соблюдать порядок: `if` -> `else if` -> `else`.

### Блок №15

Условия это конечно превосходно, но вся их сила раскрывается в тандеме с циклами. Всего есть три вида циклов,
что на самом деле лож, так как два из них в своей основе содержат третий. Сейчас станет понятнее.

Разберем фундаментальный вид циклов. Выглядит он так: `while(условие){ действие }`, и дословно значит: "Повторять
действие в фигурных скобках, до тех пор, пока правдиво условие в круглых". Правда вот есть один нюанс, если мы поместим
на место условия `true`, то цикл будет повторяться вечно. В нашем случае цикл будет повторяться до тех пор, пока не
будет введено число 5.

### Блок №16

А что делать если нам нужно четко установить количество повторений цикла? Нужна дополнительная переменная, которая будет
выступать в роли счетчика. В нашем случае мы создали переменную `k`, поставили в цикле условие `k < 5`, а в самом цикле
на каждом этапе прибавляем к ее значению 1.

### Блок №17

Теперь давай посмотрим на следующий тип циклов. Делает этот цикл ровно то же самое что и предыдущий, за одним исключением,
в написании он компактнее. Разберем все по порядку. В самом начале мы объявляем переменную-счетчик (так же туда можно поместить
уже объявленную переменную: `int l = 0;` -> `k = 0;`. Так же эту часть можно полностью опустить, написав вместо нее `;`).
Дальше мы ставим условие, в нашем случае `l < 5;` (эту часть также можно опустить написав просто `;`, но тогда цикл будет
повторяться бесконечно). Ну и последняя часть, действие которое будет выполнено при переходе на следующий круг цикла. Вместо
`l++` вполне написать `l *= 2`. В зависимости от того, что написано в последней части объявления цикла будет меняться и его
поведение. К слову, это тоже можно пропустить: просто не писать ничего на том месте, тогда нам придется или где-то в другом
месте как-то менять наше переменную `l`, или же цикл будет бесконечным.

> Сейчас стоит вернуться к тому моменту, где я сказал что переменные должны иметь разные имена. Есть такое понятие как область
> видимости. Каждый цикл, условие или функция, о который мы поговорим ниже, создают свою область видимости. В них имена переменных
> не могут повторяться. Есть еще понятие вложенности, оно значит, что внутри цикла может быть условие, и переменные, объявленные
> внутри цикла, будут доступны в условии, но вот если мы объявим переменную внутри условия, то внутри цикла за пределами условия
> эта переменная будет недоступна. В нашем случае переменная `l` может быть использована только внутри цикла.
> Если нам нужно использовать ее где-то еще, то стоит объявлять ее за пределами цикла.

### Блок №18

Теперь разберем последний вид циклов. Его используют реже всего, потому что его специфика в том, что тело цикла выполнится хотя бы
один раз, а потом произойдет проверка условия. В случае если условие ложно, цикл не пойдет на второй круг. Попробуем повторить
то что мы писали в предыдущих двух блоках. Как видим, условие не поменялось, вывод тоже, но вот цикл мы использовали другой.
Ниже я продемонстрировал что цикл выполниться хотя бы раз, даже при ложном условии.

### Блок №19

Теперь разберемся, что делать если нужно обработать не одно, не два, а, к примеру, 10 значений. Мы конечно можем создать все 10
переменных вручную и обрабатывать их по отдельности, но это, как можно догадаться, не то что бы очень эффективно. Для этого были
придуманы массивы. Давай посмотрим как они создаются. В начале, как и при создании переменных, у нас стоит тип данных, в нашем
случае `int`. После идет название массива и в квадратных скобках его длинна, то есть то, сколько значений в него можно поместить.
Опять, как и в первом блоке, попробуем не вводить никаких значений, а просто вывести массив в консоль. Что ж, это немного не то, 
чего мы ожидали. Вместо набора из десяти случайных чисел мы получили нечто, что называется адресом. Про адреса мы поговорим
чуть позже, а сейчас просто перепишем вывод так, чтоб он соответствовал нашим ожиданиям.

> Нумерация в массивах, и вообще в программировании в целом, начинается с нуля, по этому первый элемент массива это 0,
> а последний - его длинна минус один.

Все выглядит вполне естественно, за исключением того, что мы не задали значения ячейкам массива, ну и еще вывод выглядит очень
длинным.

### Блок №20

Вот и настал тот момент, когда мы будем использовать циклы для каких-то осмысленных действий. В данном случае Мы используем цикл
`for`. Значения переменной `l` (которую мы спокойно создали еще раз, при том что уже использовали это им: вспоминаем про область
видимости) будут меняться от 0 до 9, что нам идеально подходит для использования в массиве. Первый цикл задает значения ячейкам
массива, а второй их читает и выводит в консоль. Теперь это проще в написании и чтении.

### Блок №21

Теперь вернемся к адресам. Но для начала расскажу что такое ссылки и как их ее использовать. Ссылочная переменная, хранит в себе 
исключительно ссылку на первый байт переменной, на которую он ссылается (Каждая ячейка памяти имеет свой адрес, записанный в
шестнадцатеричной системе. Для доступа к значению переменной по ссылке необходимо лиш знать ее тип данных и ссылку на первый байт).
Объявляется путем прибавления к имени ссылочной переменной знака `&`. И теперь мы можем получить значение переменной `a`, 
обратившись к переменной `b`.

### Блок №22

И есть еще такое понятие как указатели. Указатель, при обращении к нему напрямую, вернет адрес переменной, ссылку на которую в 
него поместили. Посмотрим как это выглядит в коде и при выводе. Несложно заметить, что при выводе значения переменной `ptr`,
в консоли мы видим как раз тот адрес, о котором я говорил выше. Теперь посмотрим на вывод `*ptr`. Знак `*` берет не адрес, а 
значение переменной которая находиться по этому адресу - производит **разыменовывание**.

### Блок №23

Ну и напоследок посмотрим на вывод `&a` и `*&a`. `&a` Достает адрес переменной `a` (который, к слову, и записался в переменную 
`ptr`), а `*&a` разыменовывает только что взятую ссылку, что, по сути, отменяет действие `&` (как степень и корень =) )

> Отмечу так же, что ни разыменовывание, ни взятие адреса не меняет переменную `a`.

> Взятие адреса от ссылочной переменной вернет адрес переменной, на которую она ссылается.

### Блок №24

Теперь мы в полной мере можем понять, что вернул нам вывод в консоль массива `A`. Это была ссылка на первую ячейку массива. Более
того, это ссылка на первый байт первой ячейки. Теперь посмотрим что будет если разыменовать эту ссылку. Мы получили то значение,
которое записали туда в 20-ом блоке. Если мы напишем нечто вот такое: `A + 1`, то увидим еще одну ссылку, как не трудно догадаться,
это ссылка на вторую ячейку массива. Внимательно посмотрев на ее адрес, мы увидим что разница между адресом первой ячейки и второй
составляет ровно 4, что доказывает нам: во-первых, то что ссылка содержит адрес именно первого байта выделенного под переменную, 
и, во-вторых, что цело число занимает ровно 4 байта памяти. Возвращаясь к нашему массиву, если мы разыменуем ссылку `A + 1`, то
получим значение второй ячейки, в нашем случае это 1.

> Рассмотренный метод чтения значений массива имеет место, но необходимость применения возникает не часто, по этому в дальнейшем
> я буду использовать метод с квадратными скобками, который на программном уровне не отличается от метода с разыменовыванием
> ссылок на элементы, но при этом писать его проще, и выглядит он понятнее.

> Кстати, то, что чтение массива через квадратные скобки основано на переборе и разыменовывании ссылок, объясняет, почему 
> нумерация ячеек начинается с нуля, а не с единицы. Для взятия первого элемента, нам нужно просто разыменовать ссылку на первую
> ячейку, которая по совместительству является и ссылкой на массив (если мы прибавим 0, то это все еще будет ссылка на первый 
> элемент), а для второй ячейки, нам нужно прибавить 1 к ссылке массива. Именно по этому нумерация в массивах начинается с нуля.

### Блок №25

Самое время поговорить о константах. Мы их раньше уже использовали, просто не предавали этому значения. Если коротко, то
константа, это значение, которое не меняется на протяжении всего выполнения программы. Например, в строках `int a = 4;`, `b = 5;`
и `c += 2;` значения `4`, `5` и `2` являются константами. Вообще любые числа, которые мы явно записываем в код программы,
являются константами.

Теперь посмотрим на двадцать пятый блок. Мы можем задать константе некий псевдоним, записав его в память, и потом использовать 
его, обращаясь к нему по имени, как к переменной. Обрати внимание, что задать значение константе нужно сразу при объявлении, потом
поменять его уже будет нельзя. Ну и в дальнейшем мы можем достать это значение обратившись по имени к той ячейке которая хранит
эту константу.

### Блок №26

Теперь мы можем вернуться к массивам, и Вспомнить что при создании массива `A` мы воспользовались константой, значит мы можем
передать в скобки создания массива нашу ранее созданную константу `m` (Создавать массив можно только с целым количеством ячеек,
по этому передать туда `pi` не получиться, хоть это и константа). Заполним массив степенями двойки и выведем его на экран.
Как видим, элементов у нас 6, как и было записано в константе `m`.

Но что если мы попробуем при создании массива передать туда не константу, а переменную? У нас ничего не получиться, потому что
при запуске нашего кода **компилятору** - программе, которая превращает наш текст в понятный для компьютера вид, нужно выделить
под массив какое-то место, но если там стоит значение, которое может поменяться по ходу выполнения кода, то компилятор не будет
знать сколько места ему выделять.

### Блок №27

Если же нам все-таки нужен массив, с заранее не известным количеством ячеек, то мы можем воспользоваться динамическим массивом.
Для этого объявления воспользуемся уже изученным указателем. Мы создаем переменную-указатель, и помещаем в нее новый массив целых
чисел (по структуре объявления думаю понятно что происходит). В квадратные скобки мы помещаем переменную `i`, которую мы вводили
с клавиатуры в 14-ом блоке. Ну и теперь можем в ручную задать значения для ячеек.

### Блок №28

Теперь давай подумаем, что если нам нужен не просто ряд чисел, а, скажем, таблица. Например, если нам нужна таблица 5 на 5, то мы
можем взять массив из 25 ячеек и считать что первые пять элементов это первый ряд, вторые 5 это второй и так далее. Ну, или мы
можем создать массив из 5 ячеек, а в качестве значений поместить в каждую ячейку еще по одному массиву из 5 элементов. Такая
структура называется **двумерный массив** (таких итераций может быть сколько угодно, но на практике больше чем две не делают)
В 28-ом блоке Я создал двумерный массив 5 на 5. Сейчас разберем как он устроен.

Надеюсь ты еще помнишь, что массив хранит в себе адреса, по которым мы можем перемещаться, а для получения значения нам нужно 
провести разыменовывание этих адресов. Давай посмотрим что будет, если мы выведем первый адрес на который ссылается массив. Что ж,
похоже это не сильно отличается от того, что мы видели при работе с одномерным массивом. Теперь посмотрим что выведет строка
`D + 1`. Опять адрес. Попробуй отнять от второго адреса первый. Сразу скажу что разница будет ровно 20 (нужно отнять в
шестнадцатеричной системе, а потом перевести в десятичную), что значит, что одна ячейка массива `D` занимает 20 байт. Вспоминаем
что мы создавали целочисленный массив, одно целое число занимает 4 байта, делим 20 на 4, получаем 5, значит в первой ячейке 
массива `D` содержится еще один массив из 5 ячеек. Попробуем до них добраться.

В [24-ом блоке](#блок-24) мы говорили о том, как доставать значения из массива с помощью разыменовывания ссылок. Теперь попробуем
сделать то же самое с массивом `D` и выведем это в консоль. Мы опять получили ссылку, причем ту же самую что при выводе не
разыменованного `D`. Теперь прибавим 1 к тому что у нас получилось. Что-то новенькое. Теперь если мы от получившейся ссылки
`*D + 1` отнимем ссылку `*D`, то у нас получиться 4. Отлично, теперь разыменуем ссылку `*D`. Ура, мы докопались до числа, которое
там лежит!

Думаю теперь примерно понятно как это выглядит и устроено, теперь посмотрим на более простой способ достать значение из 
многомерного массива.

### Блок №29

Тут мы можем заметить кое-что новое, вложенные циклы. То есть, то произойдет, мы запустили один цикл, внутри него запустился еще
один, и уже внутри второго мы что-то делаем с массивом. Когда внутренний цикл закончиться, внешний выйдет на второй круг и опять
запустит второй цикл. Вложенность у циклов и условий может быть любого уровня и сложности.

Но вернемся к массиву. Чтобы получить доступ к ряду, нам нужно в первых скобках указать номер ряда, а для доступа уже к элементу
ряда, или же можно назвать это колонкой, нам нужно указать число во вторых скобках.

> Что считать рядом, а что столбиком решает сам программист, но зачастую за ряды принимается первый индекс.

### Блок №30

Ну и напоследок, заканчивая тему двумерных массивов поговорим про динамические двумерные массивы. Их синтаксис можно наблюдать
на первой строчке тридцатого блока. Мы создаем переменную `E` и указываем на двойную вложенность указателей.

> Вообще, на самом деле, эти звездочки должны быть рядом с названием типа данных, вот так: `int*`, `int**` и тп, так как указатель
> это отдельный тип данных (двумерный динамический массив, это указательный тип данных от указательного типа данных, от `int`),
> но писать `*` можно как рядом с названием типа данных, так и с названием переменной.

Но мы создали только внешний массив, а ведь в его ячейки нужно вложить другие динамические массивы. Сделаем это с помощью цикла.

> Если мы на этом этапе установим для каждого вложенного массива свою индивидуальную длину, то такой массив будет называться 
> зубчатым

> К элементам динамических массивов так же можно обращаться с помощью ссылок и разыменовывания.

### Блок №31

Теперь разберемся с таким понятием как функция. Вообще, все это время нах код запускался из функции которая называется `main`.
С этой функции начинается выполнение любой программы на C++. 

Разберем синтаксис функций. Функция создается почти так же как и переменная. В начале тип данных который будет возвращать функция,
после идет имя функции, которое, кстати, не может совпадать с именами переменных и других функций, количество аргументов которых
одинаково. Ну и рядом с именем круглые скобки с этими самыми аргументами. Тело функции окружено фигурными скобками, что создает
новую область видимости.

Страшно и сложно. Посмотрим на пример

```
int function(int a){
    int b = a * a;
    return b;
}
```

Теперь посмотрим как это использовать

```
int main(){
    int n = function(5);
    cout << "5^2 = " << n << endl;
}
```

В переменную `a` мы запишем результат работы функции. Что тут происходит? Мы создаем переменную `n` и после выполняем функцию
`function` с аргументом 5. Это значит что внутри функции создалась переменная `a`, которая, к слову, никак не связанна
с той переменной `a` которая находится в функции `main`. И теперь, уже в функции `function`, мы создаем переменную `b`, которую
сразу инициализируем значением `a * a` (`a` в нашем случае равно `5`). И в самом конце мы возвращаем переменную `b`, которая уже 
равна `25`.

Теперь уже в главной функции мы записываем в переменную `a` значение которое вернула `function`, то есть 25.

> Функция должна быть объявлена до ее использования. Это значит что все функции будут располагаться вверху файла.



